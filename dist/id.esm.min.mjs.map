{"version":3,"file":"id.esm.min.mjs","sources":["../src/id.ts"],"sourcesContent":["// Functions provided to other GT libraries\n\nimport XXH from 'xxhashjs';\nimport { JsxChild, JsxChildren, Variable } from './types';\n\n/**\n * Calculates a unique hash for a given string using xxhash.\n * \n * @param {string} string - The string to be hashed.\n * @returns {string} - The resulting hash as a hexadecimal string.\n */\nexport function hashString(string: string): string {\n    return XXH.h64().update(string).digest().toString(16);\n}\n\n/**\n * Calculates a unique ID for the given children objects by hashing their sanitized JSON string representation.\n * \n * @param {any} childrenAsObjects - The children objects to be hashed.\n * @returns {string} - The unique has of the children.\n */\nexport function hashJsxChildren(childrenAsObjects: JsxChildren | [JsxChildren, string]): string {\n    if (Array.isArray(childrenAsObjects)) {\n        const [children, context] = childrenAsObjects;\n        const sanitizedChildren = sanitizeJsxChildren(children);\n        const unhashedKey = JSON.stringify([sanitizedChildren, context]);\n        return hashString(unhashedKey);\n    }\n    const unhashedKey = JSON.stringify(sanitizeJsxChildren(childrenAsObjects));\n    return hashString(unhashedKey);\n}\n\ntype SanitizedElement = {\n    branches?: {\n        [k: string]: SanitizedChildren\n    },\n    children?: SanitizedChildren\n};\ntype SanitizedChild = SanitizedElement | Variable | string;\ntype SanitizedChildren = SanitizedChild | SanitizedChild[];\n\nfunction sanitizeJsxChildren(childrenAsObjects: JsxChildren): SanitizedChild[] | SanitizedChild {\n    const sanitizeChild = (child: JsxChild) => {\n        if (child && typeof child === 'object' && 'props' in child) {\n            const newChild: SanitizedChild = {};\n            const dataGt = child?.props?.['data-_gt'];\n            if (dataGt?.branches) {\n                newChild.branches = Object.fromEntries(\n                    Object.entries(dataGt.branches).map(([key, value]) => \n                        [key, sanitizeChildren(value as JsxChildren)]\n                    )\n                );\n            }\n            if (child?.props?.children) {\n                newChild.children = \n                    sanitizeChildren(child.props.children)\n            }\n            return newChild;\n        }\n        return child;\n    }\n    const sanitizeChildren = (children: JsxChildren) => {\n        return Array.isArray(children) ? children.map(sanitizeChild) : sanitizeChild(children)\n    }\n    return sanitizeChildren(childrenAsObjects);\n}\n"],"names":["hashString","string","XXH","h64","update","digest","toString","hashJsxChildren","childrenAsObjects","Array","isArray","children","context","sanitizedChildren","sanitizeJsxChildren","JSON","stringify","sanitizeChild","child","newChild","dataGt","_a","props","branches","Object","fromEntries","entries","map","key","value","sanitizeChildren","_b"],"mappings":"wBAWM,SAAUA,EAAWC,GACvB,OAAOC,EAAIC,MAAMC,OAAOH,GAAQI,SAASC,SAAS,GACtD,CAQM,SAAUC,EAAgBC,GAC5B,GAAIC,MAAMC,QAAQF,GAAoB,CAC3B,IAAAG,EAAqBH,EAAiB,GAA5BI,EAAWJ,EAAiB,GACvCK,EAAoBC,EAAoBH,GAE9C,OAAOX,EADae,KAAKC,UAAU,CAACH,EAAmBD,IAE1D,CAED,OAAOZ,EADae,KAAKC,UAAUF,EAAoBN,IAE3D,CAWA,SAASM,EAAoBN,GACzB,IAAMS,EAAgB,SAACC,WACnB,GAAIA,GAA0B,iBAAVA,GAAsB,UAAWA,EAAO,CACxD,IAAMC,EAA2B,CAAA,EAC3BC,EAAwB,QAAfC,EAAAH,aAAA,EAAAA,EAAOI,aAAQ,IAAAD,OAAA,EAAAA,EAAA,YAY9B,OAXID,aAAM,EAANA,EAAQG,YACRJ,EAASI,SAAWC,OAAOC,YACvBD,OAAOE,QAAQN,EAAOG,UAAUI,KAAI,SAACN,OAACO,EAAGP,EAAA,GAAEQ,EAAKR,EAAA,GAC5C,MAAA,CAACO,EAAKE,EAAiBD,GAAsB,OAIzC,QAAZE,EAAAb,aAAK,EAALA,EAAOI,aAAK,IAAAS,OAAA,EAAAA,EAAEpB,YACdQ,EAASR,SACLmB,EAAiBZ,EAAMI,MAAMX,WAE9BQ,CACV,CACD,OAAOD,CACX,EACMY,EAAmB,SAACnB,GACtB,OAAOF,MAAMC,QAAQC,GAAYA,EAASgB,IAAIV,GAAiBA,EAAcN,EACjF,EACA,OAAOmB,EAAiBtB,EAC5B"}